<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Node核心模块—stream | xcc</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo/profile2.png">
    <meta name="description" content="Node streams 以难以使用著称，甚至难以理解。不过有个好消息是，多年来，开发者们为了让 streams 的使用更方便，开发了很多工具包。不过本文将重点关注原生 stream API.">
    
    <link rel="preload" href="/assets/css/0.styles.3443fe78.css" as="style"><link rel="preload" href="/assets/js/app.f2921b9e.js" as="script"><link rel="preload" href="/assets/js/6.b946c0f4.js" as="script"><link rel="preload" href="/assets/js/3.ef868f41.js" as="script"><link rel="preload" href="/assets/js/26.1d3a73fe.js" as="script"><link rel="prefetch" href="/assets/js/10.17e833a5.js"><link rel="prefetch" href="/assets/js/11.f4383e7a.js"><link rel="prefetch" href="/assets/js/12.85e02cea.js"><link rel="prefetch" href="/assets/js/13.1284aa63.js"><link rel="prefetch" href="/assets/js/14.e649b201.js"><link rel="prefetch" href="/assets/js/15.dc3a9998.js"><link rel="prefetch" href="/assets/js/16.852ea923.js"><link rel="prefetch" href="/assets/js/17.33bcc64a.js"><link rel="prefetch" href="/assets/js/18.2fb48562.js"><link rel="prefetch" href="/assets/js/19.5512330e.js"><link rel="prefetch" href="/assets/js/20.79024241.js"><link rel="prefetch" href="/assets/js/21.574e21dd.js"><link rel="prefetch" href="/assets/js/22.2bc4fd97.js"><link rel="prefetch" href="/assets/js/23.bf06056e.js"><link rel="prefetch" href="/assets/js/24.08aa5266.js"><link rel="prefetch" href="/assets/js/25.f1055668.js"><link rel="prefetch" href="/assets/js/27.8dad20a0.js"><link rel="prefetch" href="/assets/js/28.858cba43.js"><link rel="prefetch" href="/assets/js/29.6eb3b46f.js"><link rel="prefetch" href="/assets/js/30.17eec879.js"><link rel="prefetch" href="/assets/js/31.20b0f51c.js"><link rel="prefetch" href="/assets/js/32.a20df63a.js"><link rel="prefetch" href="/assets/js/33.5c8d08dc.js"><link rel="prefetch" href="/assets/js/34.815b8ec0.js"><link rel="prefetch" href="/assets/js/35.80ea9da5.js"><link rel="prefetch" href="/assets/js/36.46f8fcb8.js"><link rel="prefetch" href="/assets/js/37.59a99339.js"><link rel="prefetch" href="/assets/js/38.7a5153ab.js"><link rel="prefetch" href="/assets/js/39.31b0fc00.js"><link rel="prefetch" href="/assets/js/4.79e6303a.js"><link rel="prefetch" href="/assets/js/5.7bf97a98.js"><link rel="prefetch" href="/assets/js/7.7d46e129.js"><link rel="prefetch" href="/assets/js/8.8d71c747.js"><link rel="prefetch" href="/assets/js/9.2f7cc487.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.1f3cd5b5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3443fe78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">xcc </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Home</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="https://rebel-writer-12b.notion.site/Leet-Code-2f6793a3398442778907d14919a6cb07" target="_blank" rel="noopener noreferrer" class="nav-link external">LeetCode</a></li><li class="nav-item"><a href="https://rebel-writer-12b.notion.site/Engineering-Wiki-6f04c16f81ed4fbd8f6d599237c98dfe" target="_blank" rel="noopener noreferrer" class="nav-link external">Notions</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">xcc </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Home</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="https://rebel-writer-12b.notion.site/Leet-Code-2f6793a3398442778907d14919a6cb07" target="_blank" rel="noopener noreferrer" class="nav-link external">LeetCode</a></li><li class="mobile-nav-item"><a href="https://rebel-writer-12b.notion.site/Engineering-Wiki-6f04c16f81ed4fbd8f6d599237c98dfe" target="_blank" rel="noopener noreferrer" class="nav-link external">Notions</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        Node核心模块—stream
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">xucongcong</span> <!----></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2022-02-06T00:00:00.000Z">
      2022-02-06
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-532d3a9c><a href="/tag/Node" data-v-532d3a9c><span data-v-532d3a9c>Node</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><blockquote><p>Streams are Node’s best and most misunderstood idea.
— Dominic Tarr</p></blockquote> <center><img src="/2022-1/nodestream0.png" style="zoom:50%;"></center> <p>Node streams 以难以使用著称，甚至难以理解。不过有个好消息是，多年来，开发者们为了让 streams 的使用更方便，开发了很多工具包。不过本文将重点关注原生 stream API。</p> <h2 id="_1-流到底是啥"><a href="#_1-流到底是啥" class="header-anchor">#</a> 1. 流到底是啥?</h2> <p>流是数据的集合，就像数组或字符串一样。不同之处在于流通常不是一次性使用的，并且其数据没必要全部放在内存中。这使得流在处理大量数据（或一个来自外部源且一会传来一块）时非常强大。</p> <p>然而，流不仅仅可以处理大的数据。它们还赋予了我们代码中可组合性的力量，就像我们可以通过管道其他较小的 Linux 命令来编写强大的 Linux 命令一样，我们可以在 Node 中用流做同样的事情。</p> <center><img src="/2022-1/nodestream1.png" style="zoom:50%;"></center> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> grep <span class="token operator">=</span> <span class="token operator">...</span><span class="token comment">// A stream for the grep output</span>
<span class="token keyword">const</span> wc <span class="token operator">=</span> <span class="token operator">...</span><span class="token comment">// A stream for the wc input</span>

grep<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>wc<span class="token punctuation">)</span>
</code></pre></div><p>Node 中的许多内置模块都实现了流接口：</p> <center><img src="/2022-1/nodestream2.png" style="zoom:50%;"></center> <p>上面的列表中有一些原生 Node 对象，有些对象是可读或可写流，有些对象既是可读流又是可写流，例如 TCP sockets、<code>zlib</code>和 <code>crypto</code>。</p> <p>💡注意，虽然 HTTP respnose 在客户端上是可读流，但它在服务器上是可写流。因为在 HTTP 中，我们基本上从一个对象 (http.IncomingMessage) 读取并写入另一个对象 (http.ServerResponse)。</p> <p>💡还要注意的是，当涉及到子进程时，stdio 流（stdin、stdout、stderr）如何具有逆流类型。这提供了一种非常简单的方法来使用主进程 stdio 流与这些子进程 stdio 流进行管道传输。</p> <h2 id="_2-一个简单的流的实例"><a href="#_2-一个简单的流的实例" class="header-anchor">#</a> 2. 一个简单的流的实例</h2> <p>理论说的好像很牛的样子，但通常不是 100% 有说服力。让我们看一个示例，展示在内存消耗方面流可以在代码中产生的差异。</p> <p>我们先创建一个大文件：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> file <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&quot;./big.file&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">1e6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  file<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>
    <span class="token string">&quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n&quot;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

file<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看到我用什么API创建大文件的了吗，一个可写流！</p> <p>可以使用fs模块提供的流式接口读写文件，上述例子中，我们用循环通过往可写流里面写了100万行字符。</p> <p>运行上面的脚本会生成一个大约 <strong>400 MB</strong> 的文件。</p> <p>下面是一个简单的web server 专门用来服务于这个文件的传输的：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">&quot;./big.file&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>

    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当服务器收到请求时，它将使用<code>fs.readFile</code>这个异步方法提供这个大文件。这样使用异步方式处理IO貌似看起来挺合理，主进程并不会被IO阻塞。</p> <p>好吧，让我们看看当我们运行服务器、连接到它并同时监控内存时会发生什么。</p> <p>当我刚启动服务器时，它以正常的内存量开始，8.7 MB：</p> <center><img src="/2022-1/nodestream3.png" style="zoom:50%;"></center> <p>然后我连接到服务器发送请求。注意内存消耗的变化：内存消耗跃升至 434.8 MB！</p> <center><img src="/2022-1/nodestream4.png" style="zoom:50%;"></center> <p>这种方式基本上将整个 big.file 内容放在内存中，然后再将其写入响应对象。这是非常低效的。</p> <p>HTTP响应对象也是一个可写流，这意味着如果我们有一个表示 big.file 内容的可读流，我们可以将这两者相互连接并获得几乎相同的实现方式，而不会消耗约 400 MB 内存。</p> <p>Node 的 fs 模块可以使用 createReadStream 方法为我们提供任何文件的可读流。我们可以将其通过管道传递给响应对象：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> src <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span><span class="token string">&quot;./big.file&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  src<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在，当连接到这个服务器时，神奇的事情发生了:</p> <center><img src="/2022-1/nodestream5.png" style="zoom:50%;"></center> <p><strong>发生了什么？</strong></p> <p>当客户端请求该大文件时，我们用“流”的形式一块一块的传，这意味着我们根本不会将其缓冲在内存中。内存使用量只增加了约 25 MB而已。</p> <p>您可以将此示例推向极限。用 500 万行而不是 100 万行重新生成 big.file，这将使文件超过 2 GB，这实际上大于 Node.js 中的默认缓冲区限制。</p> <p>如果你尝试使用 fs.readFile 提供该文件，则默认情况下您根本无法实现（除非手动改变缓冲区大小限制）。但是使用 fs.createReadStream 将 2 GB 数据流式传输到请求者完全没有问题，而且最重要的是，进程内存消耗不会有太大变化。</p> <p><strong>现在准备好学习流了吗？</strong></p> <h2 id="_3-流的分类"><a href="#_3-流的分类" class="header-anchor">#</a> 3. 流的分类</h2> <p>Node 中有四种基本的流类型：<strong>Readable</strong>、<strong>Writable</strong>、<strong>Duplex</strong> 和 <strong>Transform</strong> 流。</p> <ul><li>可读流是对可以从中获取数据的源的抽象。 fs.createReadStream 方法就是一个例子。</li> <li>可写流是对可以写入数据的目的地的抽象。一个例子是 fs.createWriteStream 方法。</li> <li>双工流既可读又可写。 TCP 套接字就是一个例子。</li> <li>转换流基本上是一个可用于在写入和读取数据时修改或转换数据的双工流，一个例子是 zlib.createGzip 流使用 gzip 压缩数据。您可以将转换流视为一个函数，其中输入是可写流部分，输出是可读流部分。您可能还会听说过转换流被称为“<strong>through streams“。</strong></li></ul> <p>所有流都是 EventEmitter 类的实例。它们可以触发相应的事件用于读取和写入数据。但是，我们可以使用 pipe 方法以更简单的方式使用流数据。</p> <h2 id="_4-pipe-方法"><a href="#_4-pipe-方法" class="header-anchor">#</a> 4. <strong>pipe 方法</strong></h2> <p>下面这行神奇的代码你需要记住先：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>readableSrc<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writableDest<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这简单的一行代码中，我们把可读流的输出端通过管道连接到可写流的输入端。输出端必须是可读流，输入端必须是可写流。当然也可以连接两个双工/转换流，实际上如果用管道连接双工流，pip方法会返回一个输出流，可以用来实现链式调用，可以实现类似Linux管道那样链式调用：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>a<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Which is equivalent to:</span>
a<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Which, in Linux, is equivalent to:</span>
<span class="token comment">// $ a | b | c | d</span>
</code></pre></div><p>pipe 方法是消费流最简单的方法。通常建议使用管道方法或使用事件消费流，不要混着用。通常当你使用管道方法时，你不需要使用事件，但是如果你需要以自定义的方式使用流，事件将是您的选择。</p> <h2 id="_5-流中的事件"><a href="#_5-流中的事件" class="header-anchor">#</a> 5. 流<strong>中的事件</strong></h2> <p>除了从可读流读取数据并放到可写流中，pip方法还自动帮我们管理了很多事，例如错误处理、文件关闭、速度的调节。</p> <p>然而，流还可以通过事件机制来控制，下面的代码是使用事件机制对pip方法的简单实现：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token comment">// readable.pipe(writable)</span>

readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token parameter">chunk</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  writable<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

readable<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  writable<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面是可读和可写流中的重要事件和方法的列表，列表中的事件和方法在某种程度上是相关的，因为它们通常一起使用：</p> <center><img src="/2022-1/nodestream6.png" style="zoom:50%;"></center> <p><strong>可读流上最重要的事件：</strong></p> <ul><li><code>data</code>事件：每当流将块数据传递给消费者时发出</li> <li><code>end</code>事件：当流中数据消耗消耗完时发出</li></ul> <p><strong>可写流上最重要的事件：</strong></p> <ul><li><code>drain</code>事件：可写流已被”掏空“时触发，可以接收数据了</li> <li><code>finish</code>事件：所有数据都已被写入硬件时触发</li></ul> <p>事件和函数可以结合起来使用，用于定制和优化流的使用细节。若要消耗一个可读流，我们可以使用<code>pip</code>或<code>unpip</code>方法或<code>read</code>/<code>unshift</code>/<code>resume</code>方法。若要使用一个可写流，我们可以让它作为<code>pip</code>或<code>unpip</code>方法的接收者，或使用 <code>write</code> 方法写入它并在完成后调用 <code>end</code> 方法。</p> <h2 id="_6-流动模式和暂停模式"><a href="#_6-流动模式和暂停模式" class="header-anchor">#</a> 6. 流动模式和暂停模式</h2> <p>可读流有两种主要模式，<strong>暂停模式</strong>和**流动模式，**不同模式的使用方法不同。这两种模式还被成为pull模式和push模式。</p> <p>默认情况下，所有可读流都以暂停模式启动，但可以在需要时轻松切换到流动模式或返回暂停模式。有时，切换会自动发生。</p> <p>当可读流处于暂停模式时，我们可以使用 read() 方法按需从流中读取。但是，对于流动模式下的可读流，数据是不断流动的，我们必须通过监听事件来消费它。</p> <p>在流动模式下，如果没有可用的消费者来处理数据，数据实际上可能会丢失。就是为什么当我们在流动模式下有一个可读流时，我们需要一个注册data事件的回调函数。还有一些data事件的注册是为了兼容旧的 Node 流接口。</p> <p>要在这两种流模式之间手动切换，可以使用 <code>resume()</code> 和 <code>pause()</code> 方法。</p> <p>💡 当使用 pipe 方法消费可读流时，我们不必担心这些模式，因为 pipe 会自动管理它们。</p> <hr> <p>☝ 到目前为止，我们一直仅在谈论消费流，让我们实现一些！通常要实现一个流，意味着需要导入stream模块。</p> <h2 id="_7-实现一个可写流"><a href="#_7-实现一个可写流" class="header-anchor">#</a> 7. 实现一个可写流</h2> <p>要实现可写流，我们需要使用stream模块中的 Writable 构造函数（类）：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Writable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>我们可以通过多种方式实现可写流。例如，我们可以根据需要继承并扩展 Writable 构造函数（类）：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">myWritableStream</span> <span class="token keyword">extends</span> <span class="token class-name">Writable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>但是，我更喜欢更简单的方法。我们只是从 Writable 构造函数创建一个对象，并传递给它一些选项。只需要实现一个 write 函数，这个write方法定义要写入的数据块：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Writable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> outStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Writable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>outStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个 write 方法接受三个参数：</p> <ul><li>chunk：通常是一个buffer</li> <li>encoding：可以忽略，有默认值</li> <li>callback：处理完数据块后必须要调用的函数，这是写入是否成功的信号，如果向表明失败则可以传入一个error对象。</li></ul> <p>在上面的outStream中，我们只简单的打印了chunk的字符串形式，然后在没有错误的情况下调用callback以指示成功。这是一个非常简单且看起来没什么用的”回声“流，它会返回任何接收到的内容。要使用这个流，我们可以简单地将它与 process.stdin（可读流） 一起使用，直接pip连接即可。</p> <p>当我们运行上面的代码时，我们在 process.stdin 中输入的任何内容都将使用被打印出来。</p> <p>这个可写流是一个没什么用的实现，因为它实际上已经实现并内置了，其功能类似 process.stdout：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_8-实现一个可读流"><a href="#_8-实现一个可读流" class="header-anchor">#</a> 8. 实现一个可读流</h2> <p>有一种实现可读流的简单方法。我们可以直接push希望消费者得到的数据。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Readable <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;ABCDEFGHIJKLM&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;NOPQRSTUVWXYZ&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No more data</span>

inStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当我们push一个null时，表明流中没有数据要写入了。</p> <p>当我们运行上面的代码时，我们将从 inStream 读取所有数据并将其回显到标准输出。非常简单，但也不是很高效。</p> <p>我们基本上是先将所有数据推送到流，然后才连接到标准输出流，更好的方法是当消费者请求时按需推送。我们可以通过在可读流配置中实现 read() 方法来做到这一点</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> inStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// there is a demand on the data...</span>
    <span class="token comment">// Someone wants to read it.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当在可读流上调用 read 方法时，它可以将部分数据推送到队列中。例如，我们可以一次推送一个字母，从字符代码 65（代表 A）开始，并在每次推送时递增：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> inStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentCharCode<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentCharCode <span class="token operator">&gt;</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span>currentCharCode <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">;</span>

inStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当消费者读取可读流时，read 方法将连续触发，push更多字母到流中，我们也编写了停止push的条件，push到z后停止。</p> <p>这段代码的功能和我们最开始的那段代码相同，但现在我们是按需推送数据。你应该总是这样做。</p> <h2 id="_9-实现双工-转换流"><a href="#_9-实现双工-转换流" class="header-anchor">#</a> 9. 实现双工/转换流</h2> <p>实现一个双工流意味着同时实现可读流和可写流，相当于同时继承了两个类。下面是一个双工流的示例，它结合了上面实现的两个可写和可读流：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Duplex <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> inoutStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Duplex</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">write</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">size</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentCharCode<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentCharCode <span class="token operator">&gt;</span> <span class="token number">90</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

inoutStream<span class="token punctuation">.</span>currentCharCode <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>inoutStream<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>要知道双工流的可读和可写侧完全独立于彼此运行这点很重要，这只是将两个特征组合成一个对象而已。</p> <p>转换流是更有趣的双工流，因为它的输出是根据其输入计算的。</p> <p>对于转换流，我们不必实现 read 或 write 方法，我们只需要实现一个transform方法，它具有 write 方法的签名，所以可以使用transform方法进行push操作：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Transform <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> upperCaseTr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transform</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>upperCaseTr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这个转换流中，我们使用的转换流与前面的双工流示例完全一样，我们只实现了一个 transform() 方法。</p> <h2 id="_10-流对象模式"><a href="#_10-流对象模式" class="header-anchor">#</a> 10. 流对象模式</h2> <p>默认情况下，流期待接收 Buffer/String 类型的值。我们可以设置一个 objectMode 标志，让流接受任何 JavaScript 对象。</p> <p>下面用一个简单示例来说明这一点，以下转换流的组合实现了一个功能：将一串逗号分隔值映射到 JavaScript 对象。<code>&quot;a,b,c,d&quot;</code>转换为 <code>{a: b, c: d}</code>。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> <span class="token punctuation">{</span> Transform <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> commaSplitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transform</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">readableObjectMode</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>

  <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>
      chunk
        <span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> arrayToObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transform</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">readableObjectMode</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">writableObjectMode</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chunk<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      obj<span class="token punctuation">[</span>chunk<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> chunk<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> objectToString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transform</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">writableObjectMode</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//-----------------------</span>
process<span class="token punctuation">.</span>stdin
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>commaSplitter<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>arrayToObject<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>objectToString<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><center><img src="/2022-1/nodestream7.png" style="zoom:50%;"></center> <h2 id="_11-一些内置的转换流示例"><a href="#_11-一些内置的转换流示例" class="header-anchor">#</a> 11. 一些内置的转换流示例</h2> <p>Node 有一些非常有用的内置转换流，例如 zlib、crypto 流。</p> <p>下面是一个使用 zlib.createGzip() 流结合 fs 可读/可写流来创建一个用于文件压缩的示例：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;zlib&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> file <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">createGzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>file <span class="token operator">+</span> <span class="token string">&quot;.gz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以使用此脚本对任何文件进行 gzip 压缩。我们将该文件的可读流传输到 zlib 内置转换流中，然后再传输到新 gzip 压缩文件的可写流中，很简单。</p> <p>使用pipe很酷的一点是，如果需要，我们可以将它们与事件结合起来。例如，我希望用户在脚本运行时看到进度指示器，并在脚本完成时看到“完成”消息。由于pipe方法返回目标流，我们也可以链接一个事件的注册：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;zlib&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> file <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">createGzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> process<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>file <span class="token operator">+</span> <span class="token string">&quot;.zz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;finish&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用 pipe 方法，我们可以轻松地使用流，但我们仍然可以在需要时使用事件进一步自定义与这些流的交互过程。</p> <p>管道方法的优点在于我们可以使用它以一种更易读的方式组合我们的程序。例如，相比监听数据的事件，我们可以创建一个转换流来报告进度并将 .on() 调用替换为另一个 .pipe() 调用：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;zlib&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> file <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span> Transform <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> reportProgress <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transform</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">transform</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> encoding<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    process<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">createGzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>reportProgress<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>file <span class="token operator">+</span> <span class="token string">&quot;.zz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;finish&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个 reportProgress 流是一个简单的传递流，但它也将进度报告到标准输出，请注意我如何使用 callback() 函数中的第二个参数将数据推送到 transform() 方法中，这和直接push的效果一样。</p> <p>组合流的应用是无穷无尽的。例如，如果我们需要在 gzip 之前或之后加密文件，我们需要做的就是按照我们需要的确切顺序管道另一个转换流，我们可以为此使用 Node 的crypto模块：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">const</span> crypto <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;crypto&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ..</span>

fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">createGzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>crypto<span class="token punctuation">.</span><span class="token function">createCipher</span><span class="token punctuation">(</span><span class="token string">&quot;aes192&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a_secret&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>reportProgress<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>file <span class="token operator">+</span> <span class="token string">&quot;.zz&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;finish&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的脚本把接收的文件压缩然后加密。只有知道密钥的人才能使用输出的文件。我们不能用普通的解压工具解压这个文件，因为它是加密的。</p> <p>为了真正能够解压缩使用上述脚本压缩的任何内容，我们需要以相反的顺序对 crypto 和 zlib 使用相反的流，这很简单：</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code>fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>crypto<span class="token punctuation">.</span><span class="token function">createDecipher</span><span class="token punctuation">(</span><span class="token string">&quot;aes192&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;a_secret&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">createGunzip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>reportProgress<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;finish&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Done&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>假设使用的文件是压缩版本，上面的代码将创建一个可读流流，将其通过管道传输到加密 createDecipher() 流中（使用相同的密钥），将其输出通过管道传输到 zlib createGunzip() 流中，然后将内容写回没有扩展部分的文件。</p> <p>🎉 💯</p> <h2 id="参考文档"><a href="#参考文档" class="header-anchor">#</a> 参考文档</h2> <ul><li><a href="https://jscomplete.com/learn/node-beyond-basics/node-streams" target="_blank" rel="noopener noreferrer">Node’s Streams<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#_1-流到底是啥" title="1. 流到底是啥?">1. 流到底是啥?</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_2-一个简单的流的实例" title="2. 一个简单的流的实例">2. 一个简单的流的实例</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_3-流的分类" title="3. 流的分类">3. 流的分类</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_4-pipe-方法" title="4. pipe 方法">4. pipe 方法</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_5-流中的事件" title="5. 流中的事件">5. 流中的事件</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_6-流动模式和暂停模式" title="6. 流动模式和暂停模式">6. 流动模式和暂停模式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_7-实现一个可写流" title="7. 实现一个可写流">7. 实现一个可写流</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_8-实现一个可读流" title="8. 实现一个可读流">8. 实现一个可读流</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_9-实现双工-转换流" title="9. 实现双工/转换流">9. 实现双工/转换流</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_10-流对象模式" title="10. 流对象模式">10. 流对象模式</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#_11-一些内置的转换流示例" title="11. 一些内置的转换流示例">11. 一些内置的转换流示例</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#参考文档" title="参考文档">参考文档</a></div></div></div></div> <footer class="footer" data-v-8eb634d6><div class="footer-left-wrap" data-v-8eb634d6><ul class="contact" data-v-8eb634d6><li class="contact-item" data-v-8eb634d6><a href="https://github.com/awesomexu" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-8eb634d6><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-8eb634d6><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-8eb634d6></path></svg>
          
        </a></li><li class="contact-item" data-v-8eb634d6><a href="mailto:xcc_mail@qq.com" class="nav-link external" data-v-8eb634d6><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-8eb634d6><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-8eb634d6></path><polyline points="22,6 12,13 2,6" data-v-8eb634d6></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-8eb634d6><ul class="copyright" data-v-8eb634d6><li class="copyright-item" data-v-8eb634d6><a href="https://policies.google.com/privacy?hl=en-US" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-8eb634d6>Privacy Policy</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f2921b9e.js" defer></script><script src="/assets/js/6.b946c0f4.js" defer></script><script src="/assets/js/3.ef868f41.js" defer></script><script src="/assets/js/26.1d3a73fe.js" defer></script>
  </body>
</html>
