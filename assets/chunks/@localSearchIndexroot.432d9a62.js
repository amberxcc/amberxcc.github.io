const t='{"documentCount":26,"nextId":26,"documentIds":{"0":"/about.html#about","1":"/about.html#contract","2":"/blog/posts/JavaScript-asyc.html#_1-回调函数","3":"/blog/posts/JavaScript-asyc.html#_2-promise","4":"/blog/posts/JavaScript-asyc.html#_2-1-promise-的基本用法","5":"/blog/posts/JavaScript-asyc.html#_2-2-promise-封装一个异步任务函数","6":"/blog/posts/JavaScript-asyc.html#_2-3-promise-的链式调用","7":"/blog/posts/JavaScript-asyc.html#_2-4-promise-的异常处理","8":"/blog/posts/JavaScript-asyc.html#_2-5-promise-的静态方法","9":"/blog/posts/JavaScript-asyc.html#_2-6-promise-并行执行","10":"/blog/posts/JavaScript-asyc.html#_2-7-promise-的执行时序-宏任务-微任务","11":"/blog/posts/JavaScript-asyc.html#_3-generator异步方案","12":"/blog/posts/JavaScript-asyc.html#_4-async-await语法糖","13":"/blog/posts/JavaScript-prototype.html#_1-object","14":"/blog/posts/JavaScript-prototype.html#_2-prototype","15":"/blog/posts/JavaScript-prototype.html#_3-class","16":"/blog/posts/JavaScript-prototype.html#参考文档","17":"/blog/posts/JavaScript-fp.html#_1-函数式编程基础","18":"/blog/posts/JavaScript-fp.html#_1-1-函数是一等公民","19":"/blog/posts/JavaScript-fp.html#_1-2-高阶函数","20":"/blog/posts/JavaScript-fp.html#_1-3-闭包","21":"/blog/posts/JavaScript-fp.html#_2-函数式编程核心","22":"/blog/posts/JavaScript-fp.html#_2-1-纯函数","23":"/blog/posts/JavaScript-fp.html#_2-2-副作用","24":"/blog/posts/JavaScript-fp.html#_2-3-柯里化","25":"/blog/posts/JavaScript-fp.html#_2-4-函数组合"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,10],"1":[1,1,8],"2":[2,1,32],"3":[2,1,7],"4":[4,3,39],"5":[3,3,39],"6":[4,3,53],"7":[4,3,27],"8":[4,3,22],"9":[4,3,54],"10":[8,3,45],"11":[2,1,75],"12":[3,1,38],"13":[2,1,19],"14":[2,1,108],"15":[2,1,97],"16":[1,1,15],"17":[2,1,1],"18":[2,3,16],"19":[3,3,67],"20":[3,3,27],"21":[2,1,1],"22":[3,3,59],"23":[2,3,26],"24":[3,3,83],"25":[3,3,80]},"averageFieldLength":[2.7692307692307687,2.0769230769230775,40.30769230769231],"storedFields":{"0":{"title":"About","titles":[null]},"1":{"title":"Contract","titles":[null]},"2":{"title":"1. 回调函数","titles":[null]},"3":{"title":"2. Promise","titles":[null]},"4":{"title":"2.1 Promise 的基本用法","titles":[null,"2. Promise"]},"5":{"title":"2.2 Promise 封装一个异步任务函数","titles":[null,"2. Promise"]},"6":{"title":"2.3 Promise 的链式调用","titles":[null,"2. Promise"]},"7":{"title":"2.4 Promise 的异常处理","titles":[null,"2. Promise"]},"8":{"title":"2.5 Promise 的静态方法","titles":[null,"2. Promise"]},"9":{"title":"2.6 Promise 并行执行","titles":[null,"2. Promise"]},"10":{"title":"2.7 Promise 的执行时序（宏任务&amp;微任务）","titles":[null,"2. Promise"]},"11":{"title":"3. Generator异步方案","titles":[null]},"12":{"title":"4. Async/Await语法糖","titles":[null]},"13":{"title":"1. Object","titles":[null]},"14":{"title":"2. Prototype","titles":[null]},"15":{"title":"3. Class","titles":[null]},"16":{"title":"参考文档","titles":[null]},"17":{"title":"1. 函数式编程基础","titles":[null]},"18":{"title":"1.1 函数是一等公民","titles":[null,"1. 函数式编程基础"]},"19":{"title":"1.2 高阶函数","titles":[null,"1. 函数式编程基础"]},"20":{"title":"1.3 闭包","titles":[null,"1. 函数式编程基础"]},"21":{"title":"2. 函数式编程核心","titles":[null]},"22":{"title":"2.1 纯函数","titles":[null,"2. 函数式编程核心"]},"23":{"title":"2.2 副作用","titles":[null,"2. 函数式编程核心"]},"24":{"title":"2.3 柯里化","titles":[null,"2. 函数式编程核心"]},"25":{"title":"2.4 函数组合","titles":[null,"2. 函数式编程核心"]}},"dirtCount":0,"index":[["组合函数的调试",{"2":{"25":1}}],["更复杂的组合如下",{"2":{"25":1}}],["更加利于对整体代码进行控制",{"2":{"12":1}}],["需要手动柯里化封装才能组合使用",{"2":{"25":1}}],["无法直接进行组合",{"2":{"25":1}}],["无论成功或失败只需要执行相应的回调函数即可",{"2":{"3":1}}],["上述案例中",{"2":{"25":1}}],["上图显示每个对象都有一个原型",{"2":{"15":1}}],["形式",{"2":{"25":1}}],["没必要",{"2":{"24":1}}],["没有副作用",{"2":{"22":1}}],["进一步简化",{"2":{"24":1}}],["进一步封装",{"2":{"11":1}}],["实参与形参个数不同时返回一个函数",{"2":{"24":1}}],["实参与形参个数相同时直接返回结果",{"2":{"24":1}}],["实现的的通用柯里化方法",{"2":{"24":1}}],["实现更通用的生成器函数的执行器",{"2":{"11":1}}],["实现更优的异步编程体验",{"2":{"11":1}}],["使功能更加纯净",{"2":{"24":1}}],["使用",{"2":{"25":1}}],["使用lodash通用方法组合函数",{"2":{"25":1}}],["使用f",{"2":{"24":1}}],["使用起来更方便",{"2":{"12":1}}],["使用递归优化上述代码",{"2":{"11":1}}],["使用promise封装一个ajax请求",{"2":{"5":1}}],["使用then方法分别注册promise实例的onfulfilledon和onrejected回调函数",{"2":{"4":1}}],["将",{"2":{"25":1}}],["将您功能划分为多个更细粒度的函数",{"2":{"24":1}}],["将函数从",{"2":{"24":1}}],["避免一次又一次地传递相同的变量",{"2":{"24":1}}],["为什么要使用柯里化",{"2":{"24":1}}],["为了避免回调地狱问题",{"2":{"3":1}}],["直到所有论证完毕",{"2":{"24":1}}],["直接嵌套调用",{"2":{"25":1}}],["直接在本轮调用的末尾立即执行",{"2":{"10":1}}],["直接返回一个成功的promise对象",{"2":{"8":1}}],["该函数接受第三个参数",{"2":{"24":1}}],["该函数接受第二个参数并又返回一个新函数",{"2":{"24":1}}],["该过程发生在运行时",{"2":{"14":1}}],["演算中的一个概念",{"2":{"24":1}}],["什么是柯里化",{"2":{"24":1}}],["什么情况下失败",{"2":{"4":1}}],["得到一个专门求立方的函数",{"2":{"24":1}}],["得到一个专门求平方的函数",{"2":{"24":1}}],["手动柯里化",{"2":{"24":1}}],["手动调用生成器对象的next方法",{"2":{"11":1}}],["先看看",{"2":{"24":1}}],["先看示例",{"2":{"24":1}}],["先拿到要访问的url列表",{"2":{"9":1}}],["柯里化只是意味着评估具有多个参数的函数",{"2":{"24":1}}],["柯里化是当一个函数不是一次接受所有参数",{"2":{"24":1}}],["柯里化是一个函数",{"2":{"24":1}}],["柯里化是",{"2":{"24":1}}],["柯里化",{"0":{"24":1}}],["所有与函数外的交互都可能产生副作用",{"2":{"23":1}}],["所以同步代码执行完或每次一个宏任务执行完后",{"2":{"10":1}}],["所以最后使用catch方法更像是给整个promise链条注册的失败回调",{"2":{"7":1}}],["所以then方法中注册的onrejected函数就是为promise的异常做处理",{"2":{"7":1}}],["所以嵌套使用promise是不可取的",{"2":{"6":1}}],["依此类推",{"2":{"24":1}}],["依赖外部状态",{"2":{"23":1}}],["依然没有达到传统同步代码的可读性",{"2":{"11":1}}],["副作用",{"0":{"23":1}}],["提供的函数没有被柯里化",{"2":{"25":1}}],["提供更改委托对象的能力",{"2":{"14":1}}],["提高性能",{"2":{"22":1}}],["缓存纯函数的值",{"2":{"22":1}}],["方便函数式编程",{"2":{"25":1}}],["方便并行处理",{"2":{"22":1}}],["方法",{"2":{"24":1}}],["方法进行原型操作",{"2":{"14":1}}],["方法显式设置原型",{"2":{"14":1}}],["可读性差",{"2":{"24":1}}],["可测试",{"2":{"22":1}}],["可缓存",{"2":{"22":1}}],["可以加一层打印中间结果",{"2":{"25":1}}],["可以直接组合",{"2":{"25":1}}],["可以避免重复计算",{"2":{"22":1}}],["可以用变量表示",{"2":{"18":1}}],["可以显式使用构造函数",{"2":{"15":1}}],["可以创建这个原型",{"2":{"15":1}}],["可以通过",{"2":{"14":1}}],["可以利用yield暂停生成器函数执行的特点",{"2":{"11":1}}],["可以传递参数到函数中yield的位置",{"2":{"11":1}}],["可以实现异步任务的串联执行",{"2":{"11":1}}],["可以理解为回调函数的变体",{"2":{"2":1}}],["有副作用",{"2":{"22":1}}],["有的没有",{"2":{"22":1}}],["有的副作用",{"2":{"22":1}}],["有了generator",{"2":{"12":1}}],["封装了对常用数据类型的操作方法",{"2":{"22":1}}],["封装一个",{"2":{"19":1}}],["封装一个异步任务函数",{"0":{"5":1}}],["是一个纯函数库",{"2":{"22":1}}],["是一个委托对象",{"2":{"14":1}}],["会原地改变原list的值",{"2":{"22":1}}],["会无法避免大量的回调函数嵌套",{"2":{"2":1}}],["不易出错和产生副作用",{"2":{"24":1}}],["不依赖外部",{"2":{"23":1}}],["不是纯函数",{"2":{"23":1}}],["不会改变list的值",{"2":{"22":1}}],["不过会向生成器中抛出异常",{"2":{"11":1}}],["相同输入始终到相同输出",{"2":{"23":1}}],["相同输入可能会得到不同输出",{"2":{"23":1}}],["相同输入永远得到相同输出",{"2":{"22":1}}],["相比于传统异步调用的方式",{"2":{"11":1}}],["表示的是一种映射关系",{"2":{"22":1}}],["纯函数根据相同的输入会永远的到相同的输出",{"2":{"23":1}}],["纯函数的好处",{"2":{"22":1}}],["纯函数示例",{"2":{"22":1}}],["纯函数即数学意义上的函数",{"2":{"22":1}}],["纯函数",{"0":{"22":1},"2":{"23":1}}],["hello",{"2":{"20":2}}],["handleresult",{"2":{"11":6}}],["hangzhou",{"2":{"0":1}}],["quot",{"2":{"20":2,"22":10,"24":4,"25":30}}],["来记录函数自身的创建时的环境的函数",{"2":{"20":1}}],["来实现",{"2":{"15":1}}],["通常",{"2":{"20":1}}],["通过",{"2":{"14":1}}],["闭包的本质",{"2":{"20":1}}],["闭包是指使用一个特殊的属性",{"2":{"20":1}}],["闭包",{"0":{"20":1},"2":{"20":1}}],["屏蔽细节",{"2":{"19":1}}],["把函数进一步封装抽象",{"2":{"19":1}}],["以下为模拟实现",{"2":{"19":1}}],["以此类推直到找遍整个原型链",{"2":{"14":1}}],["以此类推",{"2":{"14":1}}],["消费了5元",{"2":{"19":1}}],["元`",{"2":{"19":1}}],["生成一个只能执行一次的函数",{"2":{"19":1}}],["生成器函数的函数体才会开始执行",{"2":{"11":1}}],["生成器函数的语法就是普通函数加个",{"2":{"11":1}}],["模块提供已经柯里化的方法",{"2":{"25":1}}],["模块操作对象",{"2":{"14":1}}],["模拟实现lodash中的flow组合函数",{"2":{"25":1}}],["模拟实现",{"2":{"19":1,"24":1}}],["高阶函数的意义",{"2":{"19":1}}],["高阶函数",{"0":{"19":1}}],["继承与原型链",{"2":{"16":1}}],["壳",{"2":{"16":1}}],["酷",{"2":{"16":1}}],["|",{"2":{"16":2}}],["面向对象编程",{"2":{"16":1}}],["参考文档",{"0":{"16":1},"2":{"25":1}}],["再谈",{"2":{"16":1}}],["再补充一张简化继承关系图",{"2":{"15":1}}],["再并行访问",{"2":{"9":1}}],["函数组合可以把细粒度的函数重新组合成一个新函数",{"2":{"25":1}}],["函数组合",{"0":{"25":1}}],["函数式编程核心",{"0":{"21":1},"1":{"22":1,"23":1,"24":1,"25":1}}],["函数式编程基础",{"0":{"17":1},"1":{"18":1,"19":1,"20":1}}],["函数执行完从栈中移除",{"2":{"20":1}}],["函数在执行时会放到一个执行栈上",{"2":{"20":1}}],["函数作为返回值",{"2":{"19":1}}],["函数作为参数",{"2":{"19":1}}],["函数",{"2":{"19":2}}],["函数可以作为返回值",{"2":{"19":1}}],["函数可以作为参数",{"2":{"19":1}}],["函数只是一个特殊的对象",{"2":{"18":1}}],["函数是一等公民",{"0":{"18":1},"2":{"18":1}}],["函数对象",{"2":{"15":1}}],["函数的参数为两个处理函数",{"2":{"4":1}}],["都有自己的原型",{"2":{"15":1}}],["都会优先清空微任务队列",{"2":{"10":1}}],["甚至构造函数",{"2":{"15":1}}],["我们来看看上面构造函数例子中的完整关系图",{"2":{"15":1}}],["我们来看看其隐藏的实现的细节",{"2":{"14":1}}],["语法糖正是隐藏了这些细节",{"2":{"15":1}}],["语法糖之前",{"2":{"15":1}}],["虽然这样单级的继承使用构造函数非常简单",{"2":{"15":1}}],["仍然可以看到很多这样的遗留代码",{"2":{"15":1}}],["开发人员过去没有更好的选择",{"2":{"15":1}}],["+",{"2":{"15":1,"18":1,"22":1,"24":2}}],["构造函数的",{"2":{"15":1}}],["构造函数是用于创建实例并自动设置其原型的函数",{"2":{"15":1}}],["构造函数创建对象",{"2":{"15":1}}],["构造函数",{"2":{"15":1}}],["构建promise实例时传入一个函数",{"2":{"4":1}}],["从技术上来看",{"2":{"15":1}}],["从技术上讲",{"2":{"14":1,"15":1}}],["或",{"2":{"15":1}}],["join",{"2":{"25":5}}],["javascript",{"2":{"15":1,"16":3,"24":1,"25":1}}],["java",{"2":{"15":1}}],["jsclass",{"2":{"15":1}}],["jsconsole",{"2":{"10":1}}],["jsconst",{"2":{"6":1,"9":1,"12":1,"19":1,"22":2,"24":3,"25":3}}],["jsasync",{"2":{"12":1}}],["jsajax",{"2":{"6":1,"7":1,"9":1}}],["js的异步编程就有类似同步的编程体验了",{"2":{"12":1}}],["jsfunction",{"2":{"11":2,"15":1,"18":1,"19":2}}],["jspromise",{"2":{"8":1}}],["json",{"2":{"5":2,"7":2,"9":2,"11":4,"12":2}}],["js",{"2":{"5":1,"11":1,"14":2,"15":2,"20":1,"22":1}}],["jslet",{"2":{"4":1,"13":1,"14":1,"23":1}}],["jssettimeout",{"2":{"2":1}}],["只能尽可能的将其限制在可控范围内",{"2":{"23":1}}],["只关注结果",{"2":{"19":1}}],["只是一个理论抽象",{"2":{"15":1}}],["只会等待第一个先结束的任务",{"2":{"9":1}}],["类型的字符串转换为",{"2":{"25":1}}],["类",{"2":{"15":2}}],["类是一个正式的抽象集",{"2":{"15":1}}],["中的柯里化是什么",{"2":{"24":1}}],["中的静态调度来实现",{"2":{"15":1}}],["中基于类的继承是在基于原型的委托实现的",{"2":{"15":1}}],["中也实现了这种基于类",{"2":{"14":1}}],["作为一个语法糖",{"2":{"15":1}}],["作为其默认原型",{"2":{"14":1}}],["作为其原型",{"2":{"14":1}}],["很多面向对象语言都是基于类的概念实现继承",{"2":{"14":1}}],["尽管",{"2":{"14":1}}],["尽管没嵌套",{"2":{"11":1}}],["`消费了$",{"2":{"19":1}}],["`",{"2":{"14":1}}],["`let",{"2":{"14":1}}],["`point`",{"2":{"14":1}}],["动态分派机制允许继承链的灵活可变性",{"2":{"14":1}}],["动态分派在运行时解析引用",{"2":{"14":1}}],["必须将其原型显式设置为",{"2":{"14":1}}],["若要创建无原型的对象",{"2":{"14":1}}],["若回调中返回的是一个promise对象",{"2":{"6":1}}],["与在编译时解析引用时的静态分派相比",{"2":{"14":1}}],["因此内部函数依然可以访问外部函数成员",{"2":{"20":1}}],["因此也称为动态调度",{"2":{"14":1}}],["因为更适合链式调用",{"2":{"7":1}}],["一种用于解析继承链中的属性的机制",{"2":{"14":1}}],["一个",{"2":{"14":1}}],["一个请求promise+一个定时promise用于处理请求超时",{"2":{"9":1}}],["委托",{"2":{"14":1,"15":1}}],["则返回",{"2":{"14":1}}],["则尝试在原型中找",{"2":{"14":1}}],["则后面then方法的回调会等待他的结束",{"2":{"6":1}}],["规则很简单",{"2":{"14":1}}],["它是一种函数转换",{"2":{"24":1}}],["它一次接受一个参数并返回一个期待下一个参数的新函数",{"2":{"24":1}}],["它很容易实现",{"2":{"24":1}}],["它具体指向了函数创建时的词法环境",{"2":{"20":1}}],["它可以使用",{"2":{"15":1}}],["它允许使用一种更便捷的方式创建这样的多个对象",{"2":{"15":1}}],["它们就形成了一个分类",{"2":{"15":1}}],["它指定其对象的初始状态和行为",{"2":{"15":1}}],["它被称为原型链",{"2":{"14":1}}],["它的回调函数仍然不会立即执行而是进入回调队列中排队",{"2":{"10":1}}],["任何对象都可以作为另一个对象的原型",{"2":{"14":1}}],["任务队列的优先级划分比浏览器更加细化",{"2":{"10":1}}],["z",{"2":{"14":2,"15":6}}],["属性只是对将要构造实例的原型的引用",{"2":{"15":1}}],["属性在今天已经标准化",{"2":{"14":1}}],["属性或",{"2":{"14":1}}],["属性指向",{"2":{"13":1,"15":1}}],["每个对象在创建时都会接收到其原型",{"2":{"14":1}}],["下面让我们用原型链的概念来详细了解这种机制",{"2":{"13":1}}],["原型",{"2":{"15":1}}],["原型链是用于实现继承和共享属性的有限对象链",{"2":{"14":1}}],["原型对象用于通过动态分派机制实现继承",{"2":{"13":1}}],["原型可以是一个对象或空值",{"2":{"13":1}}],["对象字面量实际上永远不会为空",{"2":{"14":1}}],["对象将接收",{"2":{"14":1}}],["对象的原型",{"2":{"13":1}}],["对象",{"2":{"13":1}}],["对象是一个属性的集合",{"2":{"13":1}}],["对于上面定义的",{"2":{"13":1}}],["且有一个唯一的原型",{"2":{"13":1}}],["且其拿到的结果也是一个数组",{"2":{"9":1}}],["此外",{"2":{"12":1,"15":1}}],["比较麻烦",{"2":{"12":1}}],["就不太用了",{"2":{"11":1}}],["后来出现async",{"2":{"11":1}}],["后面的then就是在为前面then返回的promise注册回调",{"2":{"6":1}}],["delegate",{"2":{"14":1}}],["developer",{"2":{"0":1}}],["dict",{"2":{"14":2}}],["doesn",{"2":{"14":1}}],["done",{"2":{"11":4,"19":3}}],["data",{"2":{"11":10}}],["调用生成器函数不会立即执行",{"2":{"11":1}}],["遇到yield会暂停生成器的执行",{"2":{"11":1}}],["0",{"2":{"10":1,"19":1}}],["在函数式编程中用于创建高阶函数",{"2":{"24":1}}],["在引入",{"2":{"15":1}}],["在原型的原型中找",{"2":{"14":1}}],["在新标准中可能在外部使用",{"2":{"12":1}}],["在node中",{"2":{"10":1}}],["在浏览器环境中有两个任务队列",{"2":{"10":1}}],["在promise在执行的过程中出现错误或者主动抛出异常也会执行reject函数",{"2":{"7":1}}],["在promise里编写承诺的逻辑",{"2":{"4":1}}],["💡",{"2":{"10":1,"11":1,"14":1,"15":1,"19":1,"22":1,"23":1,"25":1}}],["number",{"2":{"15":12,"24":2}}],["null",{"2":{"14":2}}],["never",{"2":{"25":8}}],["next",{"2":{"11":10}}],["nexttick",{"2":{"10":1}}],["new",{"2":{"4":1,"5":3,"6":2,"8":1,"9":2,"11":1,"15":6}}],["node中的process",{"2":{"10":1}}],["memoize",{"2":{"22":1}}],["msg",{"2":{"20":2}}],["money",{"2":{"19":2}}],["myforeach",{"2":{"19":2}}],["mdn",{"2":{"16":1}}],["mutationobserver",{"2":{"10":1}}],["math",{"2":{"24":4}}],["makefn",{"2":{"20":2}}],["main",{"2":{"11":5,"12":3}}],["mail",{"2":{"1":1}}],["map",{"2":{"9":2,"19":2,"25":5}}],["目前await关键字只能在async函数内部使用",{"2":{"12":1}}],["目前绝大多数异步调用的api都是作为宏任务执行",{"2":{"10":1}}],["目的是为了提高整体响应能力",{"2":{"10":1}}],["也可以使用",{"2":{"15":1}}],["也可以作为当前任务的微任务",{"2":{"10":1}}],["也可以将多个promise合并为一个promise对象",{"2":{"9":1}}],["微任务队列优先级更高",{"2":{"10":1}}],["微任务的概念是后来才提到js中的",{"2":{"10":1}}],["微任务",{"0":{"10":1}}],["宏任务和微任务队列",{"2":{"10":1}}],["宏任务的执行过程中可以临时加上一些额外需求",{"2":{"10":1}}],["宏任务",{"0":{"10":1}}],["7",{"0":{"10":1}}],["等",{"2":{"19":1}}],["等中的动态调度",{"2":{"15":1}}],["等待所有任务结束才会结束",{"2":{"9":1}}],["等同于",{"2":{"7":1}}],["但不要被它吓到",{"2":{"24":1}}],["但副作用不可能完全禁止",{"2":{"23":1}}],["但如果父类很多代码就很容易变得杂乱",{"2":{"15":1}}],["但语法形式更好的结构",{"2":{"15":1}}],["但是当作用域成员被外部引用则不能释放",{"2":{"20":1}}],["但是",{"2":{"15":1}}],["但是如果需要串联执行多个异步任务",{"2":{"6":1}}],["但在实践中更喜欢使用",{"2":{"14":1}}],["但在回调队列中排队等待的任务并不是平等的",{"2":{"10":1}}],["但用generator方案还需要自己编写一个执行器函数",{"2":{"12":1}}],["但这样依然有大量的回调函数",{"2":{"11":1}}],["但promise",{"2":{"9":1}}],["ruby",{"2":{"15":1}}],["race",{"2":{"9":3}}],["reverse",{"2":{"22":1}}],["require",{"2":{"22":2,"24":2,"25":1}}],["request",{"2":{"9":2}}],["reduce",{"2":{"19":1,"25":1}}],["reflect",{"2":{"14":1}}],["return",{"2":{"5":1,"9":1,"11":4,"15":3,"18":1,"19":4,"20":1,"22":1,"23":1,"24":3,"25":3}}],["rejected",{"2":{"8":1}}],["reject",{"2":{"5":2,"6":1,"8":1,"9":2}}],["rej",{"2":{"4":2}}],["result3",{"2":{"11":3}}],["result2",{"2":{"11":3}}],["result",{"2":{"11":11,"19":4,"25":2}}],["result可以接收yield返回的值",{"2":{"11":1}}],["response",{"2":{"5":1}}],["responsetype",{"2":{"5":1}}],["resolve",{"2":{"5":2,"8":2,"9":1,"10":1}}],["res",{"2":{"4":2,"5":2,"7":4,"11":2}}],["示例一",{"2":{"20":1}}],["示例",{"2":{"9":2,"25":1}}],["其",{"2":{"15":1}}],["其次构造函数也是对象",{"2":{"15":1}}],["其实就是",{"2":{"15":1}}],["其实onrejected函数的注册还有一个更常见的用法",{"2":{"7":1}}],["其中任何一个promise失败",{"2":{"9":1}}],["数组的方法中有很多高阶函数",{"2":{"19":1}}],["数组包含每个异步任务执行的结果",{"2":{"9":1}}],["数组中每个元素都是一个promise对象",{"2":{"9":1}}],["这些函数可以处理某一项职责",{"2":{"24":1}}],["这些临时需求可以作为新的宏任务进到队列排队",{"2":{"10":1}}],["这样写显然很麻烦",{"2":{"15":1}}],["这种机制称为动态调度或委托",{"2":{"14":1}}],["这种co的实现在2015年前流行",{"2":{"11":1}}],["这个新的promise也就失败了",{"2":{"9":1}}],["这个新的promise对象才会完成",{"2":{"9":1}}],["这时候使用promise就没有任何意义了",{"2":{"6":1}}],["当几个对象共享相同的初始状态和行为时",{"2":{"15":1}}],["当其内部所有的promise都完成后",{"2":{"9":1}}],["当使用传统回调方式去完成复杂的异步流程时",{"2":{"2":1}}],["接收一个数组",{"2":{"9":1}}],["前面都是多个promise串联执行异步任务",{"2":{"9":1}}],["前面then方法中调用函数的返回值会作为后面then方法回调的参数",{"2":{"6":1}}],["并将它们分解为具有单个参数的函数序列",{"2":{"24":1}}],["并自动为其新创建的实例设置原型",{"2":{"15":1}}],["并从新创建的对象中显式继承它",{"2":{"15":1}}],["并且更容易解释",{"2":{"14":1}}],["并继承其属性",{"2":{"14":1}}],["并把后面的值返回出去",{"2":{"11":1}}],["并返回一个全新的promise对象",{"2":{"9":1}}],["并行执行",{"0":{"9":1}}],["并在成功或失败时改变状态",{"2":{"4":1}}],["并在es2015中被标准化",{"2":{"3":1}}],["6",{"0":{"9":1},"2":{"24":3}}],["快速得到一个一定是失败的promise对象",{"2":{"8":1}}],["如何实现柯里化",{"2":{"24":1}}],["如",{"2":{"14":1,"19":1}}],["如果需要调试函数组合的中间结果",{"2":{"25":1}}],["如果外部变量改变",{"2":{"23":1}}],["如果函数依赖于外部状态就无法保证相同输出",{"2":{"23":1}}],["如果我们需要从同一个原型继承多个对象",{"2":{"15":1}}],["如果最终在原型链中找不到属性",{"2":{"14":1}}],["如果在对象本身中找不到某个属性",{"2":{"14":1}}],["如果一个原型还有原型",{"2":{"14":1}}],["如果未明确设置原型",{"2":{"14":1}}],["如果接收到一个promise对象则原样返回",{"2":{"8":1}}],["如下promise回调",{"2":{"10":1}}],["如下settimeout回调",{"2":{"10":1}}],["如下例",{"2":{"4":1}}],["500",{"2":{"9":1}}],["5",{"0":{"8":1},"2":{"19":3,"22":1}}],["错误会随着promise链条传递",{"2":{"7":1}}],["除了promise的执行逻辑执行了reject函数",{"2":{"7":1}}],["除了传递回调函数参数以外",{"2":{"2":1}}],["4",{"0":{"7":1,"12":1,"25":1},"2":{"22":1}}],["prevalue",{"2":{"25":2}}],["protype",{"2":{"14":1}}],["protob",{"2":{"14":2}}],["protoa",{"2":{"14":3}}],["prototype",{"0":{"14":1},"2":{"14":4,"15":5}}],["proto",{"2":{"13":1,"14":4,"15":4}}],["promise3",{"2":{"10":2}}],["promise2",{"2":{"10":2}}],["promise1",{"2":{"10":2}}],["promise的then方法会返回一个全新的promise对象",{"2":{"6":1}}],["promise的本质也是使用回调函数",{"2":{"6":1}}],["promise实际上就是一个对象",{"2":{"3":1}}],["promise",{"0":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1},"1":{"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1},"2":{"4":3,"5":1,"6":1,"8":3,"9":6,"10":1,"12":2}}],["push",{"2":{"19":1}}],["pay",{"2":{"19":4}}],["python",{"2":{"15":1}}],["power3",{"2":{"24":2}}],["power2",{"2":{"24":3}}],["power",{"2":{"24":2}}],["pow",{"2":{"24":4}}],["point3d",{"2":{"14":4}}],["point",{"2":{"13":3,"14":2}}],["posts",{"2":{"11":6,"12":3}}],["p",{"2":{"6":2}}],["tag",{"2":{"25":6}}],["tasks",{"2":{"9":2}}],["toupper",{"2":{"25":1}}],["tolowercase",{"2":{"25":4}}],["tostring",{"2":{"14":1}}],["temp2",{"2":{"25":2}}],["temp1",{"2":{"25":2}}],["temp",{"2":{"19":3}}],["test",{"2":{"6":1}}],["true",{"2":{"19":2}}],["try",{"2":{"11":2,"12":1}}],["t",{"2":{"14":1}}],["timeout",{"2":{"9":3}}],["threesum",{"2":{"24":2}}],["threshold",{"2":{"23":4}}],["throw方法也可以让生成器继续执行",{"2":{"11":1}}],["throw",{"2":{"6":1,"11":3}}],["the",{"2":{"14":1,"16":1}}],["then",{"2":{"4":1,"5":1,"6":8,"7":3,"9":3,"10":3,"11":5,"12":1}}],["this",{"2":{"5":3,"15":5}}],["多次catch的链式调用",{"2":{"6":1}}],["value拿到返回的promise对象",{"2":{"11":1}}],["values",{"2":{"9":3}}],["value",{"2":{"6":3,"9":4,"11":5,"25":4}}],["\\tconsole",{"2":{"12":1}}],["\\t\\tconsole",{"2":{"6":1}}],["\\t\\treturn",{"2":{"6":3}}],["\\t",{"2":{"6":10,"8":1,"11":1}}],["用于实现基于原型的继承",{"2":{"14":1}}],["用于实现promise的链式调用",{"2":{"6":1}}],["用promise处理异步调用最大的优势就是可以通过链式调用解决回调嵌套的问题",{"2":{"11":1}}],["用catch方法更常见",{"2":{"7":1}}],["用来表示一个异步任务执行过后究竟是成功还是失败",{"2":{"3":1}}],["扁平化",{"2":{"6":1}}],["正确的做法是使用promise方法链式调用的特点来尽量保证串联异步任务的",{"2":{"6":1}}],["还额外增加了复杂度",{"2":{"6":1}}],["还是会出现回调地狱的问题",{"2":{"6":1}}],["还有几种常见的实现异步的方式如事件机制",{"2":{"2":1}}],["而",{"2":{"25":1}}],["而类抽象正是为了解决这个问题",{"2":{"15":1}}],["而原型本身可以有自己的原型",{"2":{"14":1}}],["而在es2017中新增了async函数同样提供了扁平化的异步编程体验",{"2":{"12":1}}],["而是接受第一个参数并返回一个新函数",{"2":{"24":1}}],["而是返回一个生成器对象",{"2":{"11":1}}],["而是等待同步代码执行完才会执行",{"2":{"4":1}}],["而作为微任务的有promise",{"2":{"10":1}}],["而promise",{"2":{"9":1}}],["而当多个任务彼此没有依赖时可以并行执行来提高执行速度",{"2":{"9":1}}],["而且promise将回调分成了两种即成功的回调和失败的回调",{"2":{"6":1}}],["即带来副作用",{"2":{"23":1}}],["即产生了副作用",{"2":{"22":1}}],["即没有副作用",{"2":{"22":1}}],["即",{"2":{"15":1}}],["即一个在语义上做同样的事情",{"2":{"15":1}}],["即它总是将",{"2":{"14":1}}],["即等待所有同步代码执行完后才会执行",{"2":{"10":1}}],["即使promise没有任何的异步操作",{"2":{"10":1}}],["即使用promise实例的catch方法注册onrejected回调",{"2":{"7":1}}],["即promise失败或者出现异常都会被执行",{"2":{"7":1}}],["即通过then方法传递进去",{"2":{"6":1}}],["即什么情况下成功",{"2":{"4":1}}],["的",{"2":{"24":1}}],["的可调用函数",{"2":{"24":1}}],["的可调用函数转换为",{"2":{"24":1}}],["的组合",{"2":{"15":1}}],["的抽象继承方式",{"2":{"14":1}}],["的执行时序",{"0":{"10":1}}],["的静态方法",{"0":{"8":1}}],["的异常处理",{"0":{"7":1}}],["的链式调用",{"0":{"6":1}}],["的基本用法",{"0":{"4":1}}],["understanding",{"2":{"25":1}}],["undefined",{"2":{"7":1,"14":2}}],["users",{"2":{"11":6,"12":3}}],["user",{"2":{"5":1,"7":2}}],["urls",{"2":{"9":4}}],["url4",{"2":{"6":1}}],["url3",{"2":{"6":1}}],["url2",{"2":{"6":1}}],["url1",{"2":{"6":1}}],["url",{"2":{"5":2,"9":1}}],["请求完成后执行onload函数",{"2":{"5":1}}],["指定相应类型为json",{"2":{"5":1}}],["指定请求方法和地址",{"2":{"5":1}}],["第一个同步任务执行才会执行提前注册的异步处理函数",{"2":{"4":1}}],["失败时调用rej函数",{"2":{"4":1}}],["fp",{"2":{"25":14}}],["flow",{"2":{"25":4}}],["f3",{"2":{"25":3}}],["f2执行后",{"2":{"25":1}}],["f2",{"2":{"25":3}}],["f1执行后",{"2":{"25":1}}],["f1",{"2":{"25":3}}],["first",{"2":{"22":1,"25":1}}],["filterlistnumber",{"2":{"25":1}}],["filter",{"2":{"19":1}}],["false",{"2":{"19":1}}],["fail2",{"2":{"6":1}}],["fail1",{"2":{"6":1}}],["failstr",{"2":{"4":2}}],["fail",{"2":{"4":1}}],["fn",{"2":{"19":4,"20":2,"25":3}}],["f",{"2":{"19":4,"24":10,"25":5}}],["from",{"2":{"14":2}}],["foo",{"2":{"11":3}}],["foreach",{"2":{"19":1}}],["for",{"2":{"6":1,"15":1,"19":3}}],["function",{"2":{"2":3,"4":3,"5":5,"7":4,"11":4,"12":1,"15":2,"19":1,"20":2}}],["environment",{"2":{"20":1}}],["end",{"2":{"10":2}}],["every",{"2":{"19":2}}],["edition",{"2":{"16":1}}],["ecmascript",{"2":{"14":1,"15":1}}],["e",{"2":{"11":4,"12":2}}],["es2015提供了generator",{"2":{"11":1}}],["err",{"2":{"5":2,"6":4,"8":1}}],["error",{"2":{"5":1,"6":4,"7":4,"8":2,"9":3,"11":6}}],["else",{"2":{"4":1,"5":1,"24":1}}],["email",{"2":{"1":1}}],["成功时调用res函数",{"2":{"4":1}}],["split",{"2":{"25":5}}],["splice",{"2":{"22":1}}],["splice方法不是纯函数",{"2":{"22":1}}],["s",{"2":{"25":9}}],["say",{"2":{"25":4}}],["same",{"2":{"14":1}}],["slice",{"2":{"22":1}}],["slice方法是纯函数",{"2":{"22":1}}],["some",{"2":{"19":1}}],["sum",{"2":{"18":2}}],["sucstr",{"2":{"4":2}}],["success",{"2":{"4":1,"8":1}}],["start",{"2":{"10":2}}],["status",{"2":{"5":2}}],["setprototypeof",{"2":{"14":2}}],["settimeout",{"2":{"2":2,"9":1,"10":3}}],["send",{"2":{"5":1}}],["item",{"2":{"19":1}}],["itemï",{"2":{"19":1}}],["i++",{"2":{"19":1}}],["i",{"2":{"19":7,"25":8}}],["ifadult2",{"2":{"23":1}}],["ifadult",{"2":{"23":1}}],["if",{"2":{"4":1,"5":1,"11":4,"19":2,"24":1}}],["inherited",{"2":{"14":2}}],["inherit",{"2":{"14":2}}],["info",{"2":{"12":1,"14":1,"20":1}}],["in",{"2":{"0":1}}],["blog",{"2":{"25":1}}],["break",{"2":{"19":1}}],["base",{"2":{"14":1}}],["bar",{"2":{"11":1}}],["b",{"2":{"4":2,"15":6,"22":1,"24":4}}],["==",{"2":{"22":1}}],["===",{"2":{"5":1,"24":2}}],["=",{"2":{"4":3,"5":3,"6":12,"8":1,"9":11,"10":4,"11":20,"12":4,"13":1,"14":7,"15":13,"18":1,"19":13,"20":2,"22":9,"23":6,"24":18,"25":29}}],["注意注册的函数不会立即执行",{"2":{"4":1}}],["执行提前注册的处理函数",{"2":{"4":1}}],["执行任务3",{"2":{"2":1}}],["执行任务2",{"2":{"2":1}}],["执行任务1",{"2":{"2":1}}],["回调队列中的任务称为宏任务",{"2":{"10":1}}],["回调地狱",{"2":{"2":1}}],["回调函数由调用者定义",{"2":{"2":1}}],["回调函数是所有异步编程方案的根基",{"2":{"2":1}}],["回调函数",{"0":{"2":1}}],["30",{"2":{"14":2}}],["3000",{"2":{"2":1}}],["3",{"0":{"6":1,"11":1,"15":1,"20":1,"24":1},"2":{"2":1,"11":1,"18":1,"19":1,"22":4,"24":9}}],["39",{"2":{"2":6,"4":6,"5":6,"6":20,"7":4,"8":4,"9":6,"10":12,"11":14,"12":6,"14":1}}],["2nd",{"2":{"16":1}}],["2015",{"2":{"14":1}}],["20",{"2":{"13":1,"14":4}}],["200",{"2":{"5":1}}],["2000",{"2":{"2":1}}],["2秒后执行任务1",{"2":{"2":1}}],["2",{"0":{"3":1,"4":1,"5":2,"6":1,"7":1,"8":1,"9":1,"10":1,"14":1,"19":1,"21":1,"22":1,"23":2,"24":1,"25":1},"1":{"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"22":1,"23":1,"24":1,"25":1},"2":{"2":1,"4":1,"11":1,"15":6,"18":1,"19":1,"22":10,"24":8,"25":1}}],["26",{"2":{"0":1,"15":6}}],["三秒后执行任务2",{"2":{"2":1}}],["g",{"2":{"11":13}}],["generic",{"2":{"15":1}}],["generator",{"2":{"11":7}}],["generator异步方案",{"0":{"11":1}}],["getlistsum",{"2":{"25":1}}],["getsum",{"2":{"24":4}}],["getpower",{"2":{"24":3}}],["getprototypeof",{"2":{"14":1}}],["getnumber",{"2":{"15":12}}],["get",{"2":{"5":1}}],["gt",{"2":{"2":3,"4":1,"6":11,"8":1,"9":7,"10":4,"11":7,"12":1,"19":4,"22":3,"23":4,"24":9,"25":14}}],["github",{"2":{"1":1}}],["lambda",{"2":{"24":1}}],["last",{"2":{"22":1}}],["l",{"2":{"22":4,"25":1}}],["lodash",{"2":{"22":3,"24":4,"25":3}}],["logrocket",{"2":{"25":1}}],["logger",{"2":{"25":3}}],["log",{"2":{"2":3,"4":3,"5":2,"6":7,"7":4,"8":1,"9":3,"10":6,"11":8,"12":4,"14":4,"15":3,"19":2,"20":1,"22":7,"24":9,"25":3}}],["l2",{"2":{"22":2,"25":1}}],["l1",{"2":{"22":2,"25":1}}],["list",{"2":{"22":5,"25":4}}],["living",{"2":{"0":1}}],["length可以获取原函数f的形参个数",{"2":{"24":1}}],["length",{"2":{"19":1,"24":4}}],["letter",{"2":{"15":14}}],["letters",{"2":{"15":1}}],["let",{"2":{"5":1,"14":5,"15":10,"19":6,"20":1,"23":1}}],["lt",{"2":{"19":1}}],["造成回调地狱问题",{"2":{"2":1}}],["发布订阅",{"2":{"2":1}}],["具体用法就是把函数作为参数传递罢了",{"2":{"2":1}}],["交给执行者执行",{"2":{"2":1}}],["18",{"2":{"23":2}}],["10",{"2":{"13":1,"14":4}}],["1000",{"2":{"2":1}}],["1秒后执行完毕",{"2":{"2":1}}],["1",{"0":{"2":1,"4":1,"13":1,"17":1,"18":2,"19":1,"20":1,"22":1},"1":{"18":1,"19":1,"20":1},"2":{"2":1,"4":1,"11":1,"15":6,"18":1,"19":1,"22":11,"24":3,"25":1}}],["163",{"2":{"1":1}}],["xmlhttprequest",{"2":{"5":1}}],["xhr",{"2":{"5":5}}],["x",{"2":{"1":1,"13":1,"14":6,"18":2,"22":3}}],["xcc",{"2":{"1":1}}],["currentfn",{"2":{"25":2}}],["currying",{"2":{"25":1}}],["curry2",{"2":{"24":1}}],["curry",{"2":{"24":3,"25":1}}],["c",{"2":{"24":4}}],["c++",{"2":{"15":1}}],["class",{"0":{"15":1},"2":{"14":1,"15":4}}],["change",{"2":{"14":1}}],["chain",{"2":{"14":1}}],["china",{"2":{"0":1}}],["create",{"2":{"14":4}}],["catch",{"2":{"6":3,"7":1,"8":1,"9":1,"11":2,"12":1}}],["coolshell",{"2":{"16":1}}],["core",{"2":{"16":1}}],["co",{"2":{"11":2,"12":1}}],["constructor",{"2":{"15":2}}],["const",{"2":{"4":1,"9":3,"11":13,"12":2,"18":1,"19":2,"20":1,"22":6,"23":2,"24":6,"25":12}}],["console",{"2":{"2":3,"4":3,"5":2,"6":6,"7":4,"8":1,"9":3,"10":5,"11":8,"12":3,"14":4,"15":3,"19":2,"20":1,"22":7,"24":9,"25":3}}],["contract",{"0":{"1":1}}],["compose",{"2":{"25":3}}],["completed",{"2":{"12":1}}],["commonjs社区提出了promise规范",{"2":{"3":1}}],["com",{"2":{"1":1}}],["of",{"2":{"19":2}}],["own",{"2":{"14":1}}],["objectc",{"2":{"14":5}}],["object",{"0":{"13":1},"2":{"9":1,"13":1,"14":11,"15":1}}],["once",{"2":{"19":3}}],["onrejcted",{"2":{"7":2}}],["onfulfilled",{"2":{"7":2}}],["onload",{"2":{"5":1}}],["ok4",{"2":{"6":1}}],["ok3",{"2":{"6":1}}],["ok2",{"2":{"6":1}}],["ok1",{"2":{"6":1}}],["open",{"2":{"5":1}}],["o",{"2":{"0":1}}],["yield",{"2":{"11":5}}],["y",{"2":{"0":1,"13":1,"14":2,"18":2,"22":3}}],["age",{"2":{"23":4}}],["arr",{"2":{"19":4}}],["array",{"2":{"19":3}}],["args2",{"2":{"24":4}}],["args1",{"2":{"24":8}}],["args",{"2":{"19":2,"25":2}}],["addwithmemory",{"2":{"22":3}}],["add",{"2":{"18":2,"22":4}}],["as",{"2":{"14":1}}],["async还会返回一个promise对象",{"2":{"12":1}}],["async",{"0":{"12":1}}],["anything",{"2":{"14":1}}],["await",{"2":{"12":2}}],["await语法糖",{"0":{"12":1}}],["await后",{"2":{"11":1}}],["amp",{"0":{"10":1},"2":{"10":2}}],["all",{"2":{"9":3,"12":1,"15":1}}],["all方法可以将多个promise合并为一个promise统一管理",{"2":{"9":1}}],["api",{"2":{"6":4,"11":4,"12":2,"14":1}}],["ajax",{"2":{"5":2,"6":3,"7":1,"9":2,"11":4,"12":2}}],["a",{"2":{"0":1,"4":2,"15":6,"22":1,"24":4}}],["about",{"0":{"0":1}}]],"serializationVersion":2}';export{t as default};
