import{_ as s,o as n,c as a,V as l}from"./chunks/framework.8ca2618e.js";const p="/2023/js-object0.png",o="/2023/js-object1.png",e="/2023/js-object2.png",t="/2023/js-object3.png",c="/2023/js-object4.png",r="/2023/js-object5.png",C=JSON.parse('{"title":"JavaScript 基于原型的面向对象","description":"","frontmatter":{"title":"JavaScript 基于原型的面向对象","date":"2022-01-15T00:00:00.000Z","author":"xcc","tags":["JavaScript"],"blog":"post","aside":"left","sidebar":false,"prev":false,"next":false},"headers":[],"relativePath":"blog/posts/JavaScript-prototype.md"}'),y={name:"blog/posts/JavaScript-prototype.md"},D=l('<p>基于原型（Prototype）的编程其实也是面向对象编程的一种方式。没有 class 化的，直接使用对象。又叫基于实例的编程。其主流的语言就是 JavaScript，与传统的面向对象编程的比较如下：</p><ul><li>在基于类的编程当中，对象总共有两种类型。类定义了对象的基本布局和函数特性，而接口是“可以使用的”对象，它基于特定类的样式。在此模型中，类表现为行为和结构的集合，对所有接口来说这些类的行为和结构都是相同的。因而，区分规则首先是基于行为和结构，而后才是状态。</li><li>原型编程的主张者经常争论说，基于类的语言提倡使用一个关注分类和类之间关系的开发模型。与此相对，原型编程看起来提倡程序员关注一系列对象实例的行为，而之后才关心如何将这些对象划分到最近的使用方式相似的原型对象，而不是分成类。</li></ul><img src="'+p+`" width="80%" style="margin:1% 10% 1% 10%;"><p>正因如此，很多基于原型的系统提倡运行时进行原型的修改，而只有极少数基于类的面向对象系统（比如第一个动态面向对象的系统 Smalltalk）允许类在程序运行时被修改。</p><ul><li>在基于类的语言中，一个新的实例通过类构造器和构造器可选的参数来构造，结果实例由类选定的行为和布局创建模型。</li><li>在基于原型的系统中构造对象有两种方法，通过复制已有的对象或者通过扩展空对象创建。很多基于原型的系统提倡运行时进行原型的修改，而基于类的面向对象系统只有动态语言允许类在运行时被修改（Python、Ruby...）</li></ul><h2 id="_1-object" tabindex="-1">1. Object <a class="header-anchor" href="#_1-object" aria-label="Permalink to &quot;1. Object&quot;">​</a></h2><blockquote><p>Object：对象是一个属性的集合，且有一个唯一的原型。原型可以是一个对象或空值。</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> point </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">y</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><img src="`+o+`" width="80%" style="margin:1% 10% 1% 10%;"><p>对于上面定义的 point 对象，<strong>proto</strong> 属性指向 point 对象的原型。原型对象用于通过动态分派机制实现继承。下面让我们用原型链的概念来详细了解这种机制。</p><h2 id="_2-prototype" tabindex="-1">2. Prototype <a class="header-anchor" href="#_2-prototype" aria-label="Permalink to &quot;2. Prototype&quot;">​</a></h2><blockquote><p>Protype：一个 prototype 是一个委托对象，用于实现基于原型的继承。</p></blockquote><p>每个对象在创建时都会接收到其原型。如果未明确设置原型，对象将接收 Object.prototype 作为其原型。可以通过 <strong>proto</strong> 属性或 <code>Object.create()</code> 方法显式设置原型：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Base object.</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> point </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">y</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Inherit from \`point\` object.</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> point3D </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">z</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">30</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> point</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;">  point3D</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">x</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 10, inherited</span></span>
<span class="line"><span style="color:#BABED8;">  point3D</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">y</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 20, inherited</span></span>
<span class="line"><span style="color:#BABED8;">  point3D</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">z </span><span style="color:#676E95;font-style:italic;">// 30, own</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre></div><blockquote><p>Prototype chain：原型链是用于实现继承和共享属性的有限对象链。</p></blockquote><p>任何对象都可以作为另一个对象的原型，而原型本身可以有自己的原型。如果一个原型还有原型，以此类推，它被称为原型链。</p><img src="`+e+`" width="80%" style="margin:1% 10% 1% 10%;"><p>规则很简单：如果在对象本身中找不到某个属性，则尝试在原型中找、在原型的原型中找，以此类推直到找遍整个原型链，如果最终在原型链中找不到属性，则返回 undefined。从技术上讲，这种机制称为动态调度或委托。</p><blockquote><p>委托：一种用于解析继承链中的属性的机制。该过程发生在运行时，因此也称为<strong>动态调度。</strong></p></blockquote><p>💡 与在编译时解析引用时的静态分派相比，动态分派在运行时解析引用。</p><p>对象字面量实际上永远不会为空，即它总是将 Object.prototype 作为其默认原型，并继承其属性。若要创建无原型的对象，必须将其原型显式设置为 null：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Doesn&#39;t inherit from anything.</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> dict </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">null</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(dict</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">toString) </span><span style="color:#676E95;font-style:italic;">// undefined</span></span></code></pre></div><p>动态分派机制允许继承链的灵活可变性，提供更改委托对象的能力：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> protoA </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">10</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> protoB </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">x</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">20</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Same as \`let objectC = {__proto__: protoA};\`:</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> objectC </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#BABED8;">(protoA)</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(objectC</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">x) </span><span style="color:#676E95;font-style:italic;">// 10</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Change the delegate:</span></span>
<span class="line"><span style="color:#BABED8;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setPrototypeOf</span><span style="color:#BABED8;">(objectC</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> protoB)</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(objectC</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">x) </span><span style="color:#676E95;font-style:italic;">// 20</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>尽管 <strong>proto</strong> 属性在今天已经标准化，并且更容易解释，但在实践中更喜欢使用 API 方法进行原型操作，如 Object.create、Object.getPrototypeOf、 Object.setPrototypeOf、通过 Reflect 模块操作对象。</p></div><p>很多面向对象语言都是基于类的概念实现继承。ECMAScript 2015 中也实现了这种基于类（class）的抽象继承方式，我们来看看其隐藏的实现的细节。</p><h2 id="_3-class" tabindex="-1">3. Class <a class="header-anchor" href="#_3-class" aria-label="Permalink to &quot;3. Class&quot;">​</a></h2><blockquote><p>Class：类是一个正式的抽象集，它指定其对象的初始状态和行为。</p></blockquote><p>当几个对象共享相同的初始状态和行为时，它们就形成了一个分类。如果我们需要从同一个原型继承多个对象，可以创建这个原型，并从新创建的对象中显式继承它：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Generic prototype for all letters.</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> letter </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">getNumber</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">number</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">number</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> letter </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">number</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> letter </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> z </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">number</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">26</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">__proto__</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> letter </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;">  a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#BABED8;">  b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#BABED8;">  z</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">() </span><span style="color:#676E95;font-style:italic;">// 26</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre></div><img src="`+t+`" width="80%" style="margin:1% 10% 1% 10%;"><p>但是，这样写显然很麻烦。而类抽象正是为了解决这个问题，作为一个语法糖（即一个在语义上做同样的事情，但语法形式更好的结构），它允许使用一种更便捷的方式创建这样的多个对象：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Letter</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">number</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">number</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">number</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F07178;">getNumber</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">number</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> z </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">26</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;">  a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#BABED8;">  b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#BABED8;">  z</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">() </span><span style="color:#676E95;font-style:italic;">// 26</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre></div><p>💡 ECMAScript 中基于类的继承是在基于原型的委托实现的。“类”只是一个理论抽象。从技术上讲，它可以使用 Java 或 C++ 中的静态调度来实现，也可以使用 JavaScript、Python、Ruby 等中的动态调度（委托）来实现。</p><p>从技术上来看，class 其实就是“构造函数 + 原型”的组合。构造函数创建对象，并自动为其新创建的实例设置原型。</p><blockquote><p>Constructor：构造函数是用于创建实例并自动设置其原型的函数。</p></blockquote><p>可以显式使用构造函数。此外，在引入 class 语法糖之前，JS 开发人员过去没有更好的选择（仍然可以看到很多这样的遗留代码）：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">number</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">number</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">number</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Letter</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#BABED8;">number</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> b </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> z </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Letter</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">26</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(</span></span>
<span class="line"><span style="color:#BABED8;">  a</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"><span style="color:#BABED8;">  b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#BABED8;">  z</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getNumber</span><span style="color:#BABED8;">() </span><span style="color:#676E95;font-style:italic;">// 26</span></span>
<span class="line"><span style="color:#BABED8;">)</span></span></code></pre></div><p>虽然这样单级的继承使用构造函数非常简单，但如果父类很多代码就很容易变得杂乱。class 语法糖正是隐藏了这些细节。</p><p>我们来看看上面构造函数例子中的完整关系图：</p><img src="`+c+'" width="80%" style="margin:1% 10% 1% 10%;"><p>上图显示每个对象都有一个原型。甚至构造函数（类）Letter 都有自己的原型，即 Function.prototype。构造函数的 prototype 属性只是对将要构造实例的原型的引用。其次构造函数也是对象（函数对象），其<code>__proto__</code> 属性指向 Object.prototype ，再补充一张简化继承关系图：</p><img src="'+r+'" width="80%" style="margin:1% 10% 1% 10%;"><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><p><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition/#execution-context" target="_blank" rel="noreferrer">JavaScript. The Core: 2nd Edition</a></p></li><li><p><a href="https://coolshell.cn/articles/6668.html" target="_blank" rel="noreferrer">再谈 javascript 面向对象编程 | 酷 壳 - CoolShell</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noreferrer">继承与原型链 - JavaScript | MDN</a></p></li></ul>',45),F=[D];function B(i,A,E,b,u,d){return n(),a("div",null,F)}const h=s(y,[["render",B]]);export{C as __pageData,h as default};
