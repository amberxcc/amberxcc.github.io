(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{341:function(t,s,a){"use strict";a.r(s);var n=a(5),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("I/O操作是计算机操作中速度最慢的一种，内存访问的时间是纳秒级，而磁盘和网络IO的访问时间则是毫秒级。不仅是速度，这两种操作的带宽差异也是这样，访问内存的带宽可以稳定在每秒几个GB，而磁盘和网络只能达到每秒几个MB，只有较好情况下才能达到每秒几个GB。")]),t._v(" "),a("p",[t._v("《UNIX 网络编程》 6.2 I/O Models 中介绍了五种网络 I/O 模型：")]),t._v(" "),a("ul",[a("li",[t._v("阻塞 I/O")]),t._v(" "),a("li",[t._v("非阻塞 I/O")]),t._v(" "),a("li",[t._v("I/O 的多路复用（select、poll、epoll）")]),t._v(" "),a("li",[t._v("信号驱动的 I/O")]),t._v(" "),a("li",[t._v("异步 I/O")])]),t._v(" "),a("h2",{attrs:{id:"_1-阻塞式i-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-阻塞式i-o"}},[t._v("#")]),t._v(" 1. 阻塞式I/O")]),t._v(" "),a("p",[t._v("在传统阻塞式I/O编程中，涉及I/O操作的函数会阻塞当前线程，只到I/O操作完成才能执行下一行代码，如下伪代码演示的就是传统的阻塞式socket操作：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// read操作会阻塞线程，只到数据可用为止")]),t._v("\ndata "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" socket"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 数据可用后才会执行后续代码")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("采用阻塞式I/O实现的Web服务器处理并发连接的方法是：每遇到一次请求，就新创建一条线程（或进程），这样的话，一个线程的阻塞操作就不会影响其他的连接了，如下图所示：")]),t._v(" "),a("center",[a("img",{staticStyle:{zoom:"50%"},attrs:{src:"/2023-3/aio0.png"}})]),t._v(" "),a("p",[t._v("从上图不难发现，阻塞式IO中每个线程的运行过程过有大量的等待时间，白白浪费了CPU的宝贵资源，不仅如此，增加了多线程带来的内存开销及线程切换的开销。")]),t._v(" "),a("h2",{attrs:{id:"_2-非阻塞式io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-非阻塞式io"}},[t._v("#")]),t._v(" 2. 非阻塞式IO")]),t._v(" "),a("p",[t._v("除了阻塞式IO，大多数操作系统还支持非阻塞时IO。在这种模式下，有关IO操作的函数不会阻塞进程，而是立即返回。处理这种IO模式，需要以轮训的方式主动查询资源是否准备好，伪代码如下：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("resources "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("socketA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" socketB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" fileA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v(" resource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isEmpty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("resource of resources"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tdata "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" resource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 尝试读取")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NO_DATA_AVALIABLE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("continue")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 没有资源准备好，进入下一次循环")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t\t"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("consume")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 资源准备好，开始消费")]),t._v("\n\t\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("相比阻塞式IO，使用非阻塞式IO的程序可以在一个线程里处理多个资源，但轮训算法依然浪费了大量的CPU时间。")]),t._v(" "),a("h2",{attrs:{id:"_3-io多路复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-io多路复用"}},[t._v("#")]),t._v(" 3. IO多路复用")]),t._v(" "),a("p",[t._v("IO复用模型的思路是系统提供一种可以同时监控多个资源的操作，有了这个函数后，应用线程通过调用此函数就可以同时监控多个资源，被监控的资源中只要有一个准备就绪了，就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起请求去读取数据，伪代码：")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("watchedList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("socketA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" FOR_READ"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nwatchedList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fileB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" FOR_READ"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻塞进程，每当有资源准备就绪时就返回事件")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("events "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" demultiplexer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("watch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("watchedList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event of events"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" RESOURCE_CLOSED"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      demultiplexer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwatch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("event"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("resource"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("consumeData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在UNIX系统中的操作系统接口是select、poll、epoll，其中epoll是对前者的优化")]),t._v("\n")])])]),a("center",[a("img",{staticStyle:{zoom:"50%"},attrs:{src:"/2023-3/aio1.png"}})]),t._v(" "),a("p",[t._v("IO多路复用的基本思路就是通过一个操作来监控多资源 ，达到不必为每个资源创建一个对应的监控线程，从而减少线程资源的开销。")]),t._v(" "),a("h2",{attrs:{id:"_4-信号驱动的io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-信号驱动的io"}},[t._v("#")]),t._v(" 4. 信号驱动的IO")]),t._v(" "),a("p",[t._v("I/O多路复用使用一个线程监控多个资源，减少了多线程监听的开销，但还是没有避免轮训算法的低效。所以就衍生了信号驱动IO模型。")]),t._v(" "),a("p",[t._v("信号驱动IO不是用轮训去监控资源就绪状态，而是在调用的时候建立一个信号联系，当内核数据准备好之后再通过信号通知线程，当线程收到信号后，此时再向内核发起读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个资源。")]),t._v(" "),a("h2",{attrs:{id:"_5-异步io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-异步io"}},[t._v("#")]),t._v(" 5. 异步IO")]),t._v(" "),a("p",[t._v("前面的几种IO方式，在数据从内核复制到应用缓冲的时候都是"),a("strong",[t._v("阻塞")]),t._v("的，即应用先得知数据是否准备好然后再去读取数据。异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。")]),t._v(" "),a("h2",{attrs:{id:"_6-关于阻塞-非阻塞、同步-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-关于阻塞-非阻塞、同步-异步"}},[t._v("#")]),t._v(" 6. 关于阻塞/非阻塞、同步/异步")]),t._v(" "),a("p",[a("strong",[t._v("阻塞、非阻塞")]),t._v("：所谓阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞。")]),t._v(" "),a("p",[a("strong",[t._v("同步、异步")]),t._v("：在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们就称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。")]),t._v(" "),a("p",[a("strong",[t._v("同步阻塞、同步非阻塞")]),t._v("：他们不同的只是发起读取请求的时候一个请求阻塞，一个请求不阻塞，但是相同的是，他们都需要应用自己监控整个数据完成的过程。而为什么"),a("strong",[t._v("只有异步非阻塞")]),t._v(" 而没有异步阻塞呢，因为异步模型下请求指定发送完后就即刻返回了，没有任何后续流程了，所以它注定不会阻塞，所以也就只会有异步非阻塞模型了。")]),t._v(" "),a("h2",{attrs:{id:"_7-libuv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-libuv"}},[t._v("#")]),t._v(" 7. libuv")]),t._v(" "),a("p",[t._v("每个操作系统都有自己的多路复用接口，Linux的epoll，macOS的kqueue、Windows的IOCP。此外同一种I/O操作在不同类型的资源上，可能会有相当不同的行为，就算操作系统一样，还是会因为资源类型不同而产生差异。如UNIX操作系统中常规的文件不支持非阻塞操作，因此为了模拟非阻塞行为，必须使用相应的机制来模拟。")]),t._v(" "),a("center",[a("img",{staticStyle:{zoom:"50%"},attrs:{src:"/2023-3/aio2.png"}})]),t._v(" "),a("p",[t._v("libuv是Node.js核心团队为了解决解决上述问题创建的异步IO原生库，除了把底层操作系统间的差异抽象掉，libuv还实现了reactor模式，因此它会提供一套API让开发者能够建立时间循环、管理事件队列、运行异步I/O操作，并将其他类型的任务加入队列")]),t._v(" "),a("h2",{attrs:{id:"参考文档"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://book.douban.com/subject/35506007/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.js Design Patterns"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://www.geeksforgeeks.org/libuv-in-node-js/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Libuv in Node.js - GeeksforGeeks"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://time.geekbang.org/column/article/9851",target:"_blank",rel:"noopener noreferrer"}},[t._v("异步I/O模型和Lock-Free编程-极客时间"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/161357177",target:"_blank",rel:"noopener noreferrer"}},[t._v("IO模型和基于事件驱动的IO多路复用模式"),a("OutboundLink")],1)])])],1)}),[],!1,null,null,null);s.default=e.exports}}]);