(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{338:function(t,r,e){"use strict";e.r(r);var _=e(5),o=Object(_.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Goroutine 的调度本来是 Go 语言核心开发团队才应该关注的事情，大多数 Gopher 们无需关心。但了解 Goroutine 的调度模型和基本原理，能够帮助我们编写出更高质量的 Go 代码。")]),t._v(" "),e("h2",{attrs:{id:"_1-进程与线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程与线程"}},[t._v("#")]),t._v(" 1. 进程与线程")]),t._v(" "),e("h3",{attrs:{id:"_1-1-进程与线程的创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-进程与线程的创建"}},[t._v("#")]),t._v(" 1.1 进程与线程的创建")]),t._v(" "),e("hr"),t._v(" "),e("p",[e("strong",[t._v("进程")]),t._v("是资源分配的基本单位，"),e("strong",[t._v("线程")]),t._v("是可被调度的基本单位。在 linux 系统中，进程和线程都用 task_struct 来描述，只不过通过pthread创建的线程共享同一份系统资源。")]),t._v(" "),e("center",[e("img",{staticStyle:{zoom:"50%"},attrs:{src:"/2023-3/go-scheduler1.png"}})]),t._v(" "),e("h3",{attrs:{id:"_1-2-进程与线程的开销"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-进程与线程的开销"}},[t._v("#")]),t._v(" 1.2 进程与线程的开销")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("线程切换开销：切换开销大，会导致CPU大部分时间浪费在切换上")]),t._v(" "),e("ul",[e("li",[t._v("进程切换的直接开销包括：切换页表全局目录、切换内核态堆栈、切换硬件上下文、刷新TLB、系统调度器代码的执行等，此外还包括CPU缓存失效导致的间接IO开销。")]),t._v(" "),e("li",[t._v("线程本质上是一批共享资源的进程，线程切换的本质还是进程开销。只不过由于共享虚拟内存，线程切换开销主要节省了虚拟地址空间的切换。")])]),t._v(" "),e("p",[t._v("内存开销：创建一个内核级的线程，有2MB的固定栈内存开销，在高并发场景下内存开销较大")]),t._v(" "),e("h2",{attrs:{id:"_2-协程与goroutine"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-协程与goroutine"}},[t._v("#")]),t._v(" 2. 协程与goroutine")]),t._v(" "),e("p",[t._v("协程表示一个用户态的轻量级线程，在用户态即可对执行单元进行创建、销毁操作，效率更高。使用M : N的协程模型可以充分利用多核CPU。")]),t._v(" "),e("center",[e("img",{staticStyle:{zoom:"25%"},attrs:{src:"/2023-3/go-scheduler2.png"}})]),t._v(" "),e("h3",{attrs:{id:"_2-1-gmp模型基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-gmp模型基础"}},[t._v("#")]),t._v(" 2.1 GMP模型基础")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("目前Go语言基于GMP模型实现用户态线程：")]),t._v(" "),e("ul",[e("li",[t._v("G（goroutine）：每个goroutine都有自己的栈空间、定时器，goroutine的初始栈空间只有2KB（OS线程固定2MB），且可以按需扩展。")]),t._v(" "),e("li",[t._v("M（Machine）：内核线程的抽象，记录内核线程的栈信息，当goroutine调度到线程上时，使用该goroutine自己的栈信息。（M的数量是动态创建、销毁的）")]),t._v(" "),e("li",[t._v("P（Processor）：逻辑处理器，负责调度goroutine，P关联了的本地可运行G的队列，每一个P最多关联256个G。（P数量可通过GOMAXPROCS参数可以设置数量）")])]),t._v(" "),e("center",[e("img",{staticStyle:{zoom:"40%"},attrs:{src:"/2023-3/go-scheduler3.png"}})]),t._v(" "),e("h3",{attrs:{id:"_2-2-goroutine-的调度策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-goroutine-的调度策略"}},[t._v("#")]),t._v(" 2.2 goroutine 的调度策略")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("Goroutine 调度器的实现不是一蹴而就的，它的调度模型与算法也是几经演化，从最初的G-M模型、到G-P-M模型，从不支持抢占，到支持协作式抢占，再到支持基于信号的异步抢占，Goroutine 调度器经历了不断地优化与打磨。")]),t._v(" "),e("p",[t._v("调度策略举例：")]),t._v(" "),e("ul",[e("li",[t._v("多线程调度：可以通过GOMAXPROCS参数设置P个数，可以充分利用多核的优势")]),t._v(" "),e("li",[t._v("抢占式调度：一个goroutine最多占用CPU10ms，防止其他goroutine产生饥饿")]),t._v(" "),e("li",[t._v("任务窃取：本地队列没有可用的G时，会尝试从其他P队列中偷取G")]),t._v(" "),e("li",[t._v("hand off机制：当线程阻塞时，线程会释放与P的绑定，把P转给其他空闲的线程执行；")]),t._v(" "),e("li",[t._v("全局G队列：当M通过working stealing机制无法获取其他P中的G时会从全局中取G（通过锁）")])]),t._v(" "),e("h3",{attrs:{id:"_2-3-goroutine-的执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-goroutine-的执行"}},[t._v("#")]),t._v(" 2.3 goroutine 的执行")]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("G的创建：通过go创建一个G，首先尝试放入创建G时的本地队列，如果满了则放在全局队列")]),t._v(" "),e("br"),t._v(" "),e("p",[t._v("G的执行：")]),t._v(" "),e("ul",[e("li",[t._v("P中没有G：尝试从其他P队列或者全局队列获取G执行")]),t._v(" "),e("li",[t._v("P中有G：优先调度本地队列中的G\n"),e("ul",[e("li",[t._v("G执行超时：从P队列调度G执行 → 超时返回队列 → 调度下一个G")]),t._v(" "),e("li",[t._v("G执行完毕：从P队列调度G执行 → G执行完毕后销毁 → 调度下一个G")]),t._v(" "),e("li",[t._v("G阻塞：从P队列调度G执行 → G阻塞 → 创建或唤醒一个M继续服务P")]),t._v(" "),e("li",[t._v("G从阻塞恢复：G返回全局队列，M先尝试抢原来的P，再尝试找空闲的P，否则进入休眠")])])])]),t._v(" "),e("h2",{attrs:{id:"参考文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go 语言调度器与 Goroutine 实现原理"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://time.geekbang.org/column/article/476643",target:"_blank",rel:"noopener noreferrer"}},[t._v("32｜并发：聊聊Goroutine调度器的原理-极客时间"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.yuque.com/aceld/golang/srxd6d#ff36f980",target:"_blank",rel:"noopener noreferrer"}},[t._v("2、Golang的协程调度器原理及GMP设计思想 · 语雀"),e("OutboundLink")],1)])])])],1)}),[],!1,null,null,null);r.default=o.exports}}]);